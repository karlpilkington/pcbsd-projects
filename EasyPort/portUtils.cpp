#include "portUtils.h"

QStringList PortUtils::generateNewMakefile(QString name, QString version, QString category, QString mastersite, QString maintainer, QString comment){
  //This generates a "quick porting" Makefile template that can be added on to later
  QStringList out;
  out << "# Port template generated by EasyPort version 1.0";
  out << "# $FreeBSD$";
  out << "";
  out << "# General Port information #";
  out << "PORTNAME=\t"+name;
  out << "PORTVERSION=\t"+version;
  out << "CATEGORIES=\t"+category;
  out << "MASTER_SITES=\t"+mastersite;
  out << "";
  out << "MAINTAINER=\t"+maintainer;
  out << "COMMENT=\t"+comment;
  out << "";
  out << ".include <bsd.port.mk>";

  return out;
}

QStringList PortUtils::findPortCategories(QString portdir){
  //search through the available ports tree and find the valid categories
  QStringList cats;
  QDir dir(portdir);
  if(dir.exists()){
    QStringList raw = dir.entryList(QDir::Dirs | QDir::NoDotAndDotDot, QDir::Name);
    for(int i=0; i<raw.length(); i++){
      //check each raw directory to see if it is a valid ports collection
      if( (raw[i]!="distfiles") && raw[i].at(0).isLower() ){
      	cats << raw[i];      
      }
    }
  }
  return cats;
}

QStringList PortUtils::getMakefileConfigOpts(){
  QStringList opt;
  //These should be listed in their order of appearance in the Makefile
  opt << "PORTNAME:::"+QObject::tr("Name for the port");
  opt << "PORTVERSION:::"+QObject::tr("Current version of the application");
  opt << "CATEGORIES:::"+QObject::tr("FreeBSD categories to put the port in");
  opt << "MASTER_SITES:::"+QObject::tr("URL for the master location(s) to look for the application source");
  opt << "MASTER_SITE_SUBDIR:::"+QObject::tr("Master Site subdirectory to look for application source");
  opt << "PKGNAMEPREFIX:::"+QObject::tr("Prefix for the application source file");
  opt << "PKGNAMESUFFIX:::"+QObject::tr("Suffix for the application source file");
  opt << "DISTNAME:::"+QObject::tr("");
  opt << "EXTRACT_SUFX:::"+QString(QObject::tr("Alternate source suffix if not the standard %1")).arg("\"*.tar.gz\"");
  opt << "DISTFILES:::"+QObject::tr("");
  opt << "EXTRACT_ONLY:::"+QObject::tr("");
  opt << "PATCH_SITES:::"+QObject::tr("URL to fetch patch files");
  opt << "PATCHFILES:::"+QObject::tr("Names of the patch files to use");
  opt << "MAINTAINER:::"+QObject::tr("Port maintainer email address (usually yours if you are creating it)");
  opt << "COMMENT:::"+QObject::tr("Short description of the application");
  opt << "RUN_DEPENDS:::"+QObject::tr("Runtime dependencies for the application");
  
  return opt;
}


// ======================
//   GENERAL UTILITIES
// ======================
bool PortUtils::runCmd(QString indir, QString cmd, QStringList args){
  QProcess proc;
  if(!indir.isEmpty() && QFile::exists(indir) ){
    proc.setWorkingDirectory(indir);
  }
  if(args.isEmpty()){ proc.start(cmd); }
  else{ proc.start(cmd,args); }
  while( !proc.waitForFinished(300) ){
    QCoreApplication::processEvents(); //make sure we don't hang the GUI	  
  }
  return (proc.exitCode() == 0);
}

void PortUtils::compressDir(QString dirPath){
  //Compress the directory
  QString localDir = dirPath.section("/",-1);
  //QString cmd = "cd "+dirPath+"/..; tar czf "+localDir+".tar.gz "+localDir;
  QStringList args; args << "czf" << localDir+".tar.gz" << localDir;
  qDebug() << "Compressing dir:" << dirPath+".tar.gz";
  dirPath.chop(localDir.length()); //go up one directory
  PortUtils::runCmd(dirPath, "tar", args);
  return;
}

bool PortUtils::createFile(QString fileName, QStringList contents){
//fileName = full path to file (I.E. /home/pcbsd/junk/junk.txt)
//contents = list of lines to be written (one line per entry in the list - no newline needed at the end of an entry)
	
  //Check if this is actually a file removal
  if(contents.isEmpty() && QFile::exists(fileName)){
    bool good = QFile::remove(fileName);
    if(!good){
      qDebug() << fileName+": Could not be deleted";
    }
    return good;
  }else if(contents.isEmpty()){
    return true; //File to delete already does not exist 
  }
  
  //Check that the parent directory exists, and create it if necessary
  QString pDir = fileName;
  pDir.chop( fileName.section("/",-1).length() );
  QDir dir(pDir);
    if(!dir.exists()){ 
      qDebug() << "Create parent Directory:" << dir.absolutePath();
      if( !dir.mkpath(dir.absolutePath()) ){
        qDebug() << fileName+": Could not create containing directory";
	return false;
      }
    }

  //Open the file with .tmp extension
  QFile file(fileName+".tmp");
  if( !file.open(QIODevice::WriteOnly | QIODevice::Text) ){
    qDebug() << fileName+".tmp: Failure -- Could not open file";
    return false;
  }
  //Write the file
  QTextStream ofile(&file); //start the output stream
  for(int i=0; i<contents.length(); i++){
    ofile << contents[i];
    ofile << "\n";
  }
  //Close the File
  file.close();
  //Remove any existing file with the final name/location
  if( QFile::exists(fileName) ){
    if( !QFile::remove(fileName) ){
      qDebug() << fileName+": Error -- Could not overwrite existing file";
      QFile::remove(fileName+".tmp");
      return false;
    }
  }
  //Move the temporary file into its final location
  if( !file.rename(fileName) ){
    qDebug() << fileName+": Error: Could not rename "+fileName+".tmp as "+fileName;
    return false;
  }
  //Return success
  QString extra = QDir::homePath(); //remove this from the filename display
  qDebug() << "Saved:" << fileName.replace(extra,"~");
  return true;;
}

bool PortUtils::removeFile(QString fileName){
  return PortUtils::createFile(fileName, QStringList() );
}

QStringList PortUtils::readFile(QString filePath){
  QStringList contents;
  //Check that the file exists first
  if(!QFile::exists(filePath)){ 
    qDebug() << "Warning: file to read does not exist:" << filePath;
    return contents; 
  }
  //Open the file for reading
  QFile file(filePath);
  if(!file.open(QIODevice::ReadOnly | QIODevice::Text)){ 
    qDebug() << "Error: file could not be opened for reading:"<< filePath;
    return contents; 
  }
  QTextStream in(&file);
  //Save the contents as a QStringList
  while(!in.atEnd()){
    contents << in.readLine();
  }
  //Return the contents (one entry per line)
  return contents;
}

